/**
 * OSHI (https://github.com/oshi/oshi)
 *
 * Copyright (c) 2010 - 2019 The OSHI Project Team:
 * https://github.com/oshi/oshi/graphs/contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
// This file was automatically generated by the OSHI API generator; do not edit!
package oshi.api.hardware.disk.internal;

import java.lang.Override;
import javax.annotation.processing.Generated;
import oshi.api.AttributeKey;
import oshi.api.DetachedContainerException;
import oshi.api.hardware.disk.Disk;
import oshi.api.internal.AbstractContainer;
import oshi.driver.ComponentDriver;

/**
 * A storage device
 */
@Generated("oshi.ApiGenerator")
public abstract class DiskContainer extends AbstractContainer implements Disk {
    public String name;

    public String path;

    public String model;

    public String serial;

    /**
     * The disk's total size in bytes
     */
    public Long size;

    public Long reads;

    public Long readBytes;

    public Long writes;

    public Long writeBytes;

    public Long queueLength;

    public Long transferTime;

    public String modelFamily;

    public String firmwareVersion;

    public Long rotationRate;

    public Long readErrorRate;

    public Long spinUpTime;

    public Long startStopCycles;

    public Long reallocatedSectors;

    public Long seekErrorRate;

    public Long powerOnTime;

    public Long spinRetries;

    public Long calibrationRetries;

    public Long powerCycles;

    public Long poweroffRetracts;

    public Long loadCycles;

    public Long temperature;

    public Long reallocatedEvents;

    public Long currentPendingSector;

    public Long offlineUncorrectable;

    public Long crcErrors;

    public Long multizoneErrorRate;

    @Override
    public String getName() {
        return name;
    }

    @Override
    public String getPath() {
        return path;
    }

    @Override
    public String getModel() {
        return model;
    }

    @Override
    public String getSerial() {
        return serial;
    }

    @Override
    public Long getSize() {
        return size;
    }

    @Override
    public Long querySize() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(DiskAttributeEnum.SIZE);
        return size;
    }

    @Override
    public Long getReads() {
        return reads;
    }

    @Override
    public Long queryReads() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(DiskAttributeEnum.READS);
        return reads;
    }

    @Override
    public Long getReadBytes() {
        return readBytes;
    }

    @Override
    public Long queryReadBytes() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(DiskAttributeEnum.READ_BYTES);
        return readBytes;
    }

    @Override
    public Long getWrites() {
        return writes;
    }

    @Override
    public Long queryWrites() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(DiskAttributeEnum.WRITES);
        return writes;
    }

    @Override
    public Long getWriteBytes() {
        return writeBytes;
    }

    @Override
    public Long queryWriteBytes() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(DiskAttributeEnum.WRITE_BYTES);
        return writeBytes;
    }

    @Override
    public Long getQueueLength() {
        return queueLength;
    }

    @Override
    public Long queryQueueLength() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(DiskAttributeEnum.QUEUE_LENGTH);
        return queueLength;
    }

    @Override
    public Long getTransferTime() {
        return transferTime;
    }

    @Override
    public Long queryTransferTime() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(DiskAttributeEnum.TRANSFER_TIME);
        return transferTime;
    }

    @Override
    public String getModelFamily() {
        return modelFamily;
    }

    @Override
    public String queryModelFamily() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(DiskAttributeEnum.MODEL_FAMILY);
        return modelFamily;
    }

    @Override
    public String getFirmwareVersion() {
        return firmwareVersion;
    }

    @Override
    public String queryFirmwareVersion() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(DiskAttributeEnum.FIRMWARE_VERSION);
        return firmwareVersion;
    }

    @Override
    public Long getRotationRate() {
        return rotationRate;
    }

    @Override
    public Long queryRotationRate() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(DiskAttributeEnum.ROTATION_RATE);
        return rotationRate;
    }

    @Override
    public Long getReadErrorRate() {
        return readErrorRate;
    }

    @Override
    public Long queryReadErrorRate() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(DiskAttributeEnum.READ_ERROR_RATE);
        return readErrorRate;
    }

    @Override
    public Long getSpinUpTime() {
        return spinUpTime;
    }

    @Override
    public Long querySpinUpTime() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(DiskAttributeEnum.SPIN_UP_TIME);
        return spinUpTime;
    }

    @Override
    public Long getStartStopCycles() {
        return startStopCycles;
    }

    @Override
    public Long queryStartStopCycles() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(DiskAttributeEnum.START_STOP_CYCLES);
        return startStopCycles;
    }

    @Override
    public Long getReallocatedSectors() {
        return reallocatedSectors;
    }

    @Override
    public Long queryReallocatedSectors() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(DiskAttributeEnum.REALLOCATED_SECTORS);
        return reallocatedSectors;
    }

    @Override
    public Long getSeekErrorRate() {
        return seekErrorRate;
    }

    @Override
    public Long querySeekErrorRate() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(DiskAttributeEnum.SEEK_ERROR_RATE);
        return seekErrorRate;
    }

    @Override
    public Long getPowerOnTime() {
        return powerOnTime;
    }

    @Override
    public Long queryPowerOnTime() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(DiskAttributeEnum.POWER_ON_TIME);
        return powerOnTime;
    }

    @Override
    public Long getSpinRetries() {
        return spinRetries;
    }

    @Override
    public Long querySpinRetries() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(DiskAttributeEnum.SPIN_RETRIES);
        return spinRetries;
    }

    @Override
    public Long getCalibrationRetries() {
        return calibrationRetries;
    }

    @Override
    public Long queryCalibrationRetries() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(DiskAttributeEnum.CALIBRATION_RETRIES);
        return calibrationRetries;
    }

    @Override
    public Long getPowerCycles() {
        return powerCycles;
    }

    @Override
    public Long queryPowerCycles() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(DiskAttributeEnum.POWER_CYCLES);
        return powerCycles;
    }

    @Override
    public Long getPoweroffRetracts() {
        return poweroffRetracts;
    }

    @Override
    public Long queryPoweroffRetracts() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(DiskAttributeEnum.POWEROFF_RETRACTS);
        return poweroffRetracts;
    }

    @Override
    public Long getLoadCycles() {
        return loadCycles;
    }

    @Override
    public Long queryLoadCycles() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(DiskAttributeEnum.LOAD_CYCLES);
        return loadCycles;
    }

    @Override
    public Long getTemperature() {
        return temperature;
    }

    @Override
    public Long queryTemperature() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(DiskAttributeEnum.TEMPERATURE);
        return temperature;
    }

    @Override
    public Long getReallocatedEvents() {
        return reallocatedEvents;
    }

    @Override
    public Long queryReallocatedEvents() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(DiskAttributeEnum.REALLOCATED_EVENTS);
        return reallocatedEvents;
    }

    @Override
    public Long getCurrentPendingSector() {
        return currentPendingSector;
    }

    @Override
    public Long queryCurrentPendingSector() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(DiskAttributeEnum.CURRENT_PENDING_SECTOR);
        return currentPendingSector;
    }

    @Override
    public Long getOfflineUncorrectable() {
        return offlineUncorrectable;
    }

    @Override
    public Long queryOfflineUncorrectable() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(DiskAttributeEnum.OFFLINE_UNCORRECTABLE);
        return offlineUncorrectable;
    }

    @Override
    public Long getCrcErrors() {
        return crcErrors;
    }

    @Override
    public Long queryCrcErrors() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(DiskAttributeEnum.CRC_ERRORS);
        return crcErrors;
    }

    @Override
    public Long getMultizoneErrorRate() {
        return multizoneErrorRate;
    }

    @Override
    public Long queryMultizoneErrorRate() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(DiskAttributeEnum.MULTIZONE_ERROR_RATE);
        return multizoneErrorRate;
    }

    public void attach(ComponentDriver driver) {
        this.driver = driver;
        // Query all constant attributes:
        driver.query(DiskAttributeEnum.NAME);
        driver.query(DiskAttributeEnum.PATH);
        driver.query(DiskAttributeEnum.MODEL);
        driver.query(DiskAttributeEnum.SERIAL);
    }

    @Override
    public <T> T get(AttributeKey<T> key) {
        switch ((DiskAttributeEnum) key.getAttributeEnum()) {
        default:
            return null;
        case NAME:
            return (T) name;
        case PATH:
            return (T) path;
        case MODEL:
            return (T) model;
        case SERIAL:
            return (T) serial;
        case SIZE:
            return (T) size;
        case READS:
            return (T) reads;
        case READ_BYTES:
            return (T) readBytes;
        case WRITES:
            return (T) writes;
        case WRITE_BYTES:
            return (T) writeBytes;
        case QUEUE_LENGTH:
            return (T) queueLength;
        case TRANSFER_TIME:
            return (T) transferTime;
        case MODEL_FAMILY:
            return (T) modelFamily;
        case FIRMWARE_VERSION:
            return (T) firmwareVersion;
        case ROTATION_RATE:
            return (T) rotationRate;
        case READ_ERROR_RATE:
            return (T) readErrorRate;
        case SPIN_UP_TIME:
            return (T) spinUpTime;
        case START_STOP_CYCLES:
            return (T) startStopCycles;
        case REALLOCATED_SECTORS:
            return (T) reallocatedSectors;
        case SEEK_ERROR_RATE:
            return (T) seekErrorRate;
        case POWER_ON_TIME:
            return (T) powerOnTime;
        case SPIN_RETRIES:
            return (T) spinRetries;
        case CALIBRATION_RETRIES:
            return (T) calibrationRetries;
        case POWER_CYCLES:
            return (T) powerCycles;
        case POWEROFF_RETRACTS:
            return (T) poweroffRetracts;
        case LOAD_CYCLES:
            return (T) loadCycles;
        case TEMPERATURE:
            return (T) temperature;
        case REALLOCATED_EVENTS:
            return (T) reallocatedEvents;
        case CURRENT_PENDING_SECTOR:
            return (T) currentPendingSector;
        case OFFLINE_UNCORRECTABLE:
            return (T) offlineUncorrectable;
        case CRC_ERRORS:
            return (T) crcErrors;
        case MULTIZONE_ERROR_RATE:
            return (T) multizoneErrorRate;
        }
    }
}
