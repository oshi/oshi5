/**
 * OSHI (https://github.com/oshi/oshi)
 *
 * Copyright (c) 2010 - 2019 The OSHI Project Team:
 * https://github.com/oshi/oshi/graphs/contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
// This file was automatically generated by the OSHI API generator; do not edit!
package oshi.api.hardware.nic.internal;

import java.lang.Override;
import javax.annotation.processing.Generated;
import oshi.api.AttributeKey;
import oshi.api.DetachedContainerException;
import oshi.api.hardware.nic.Nic;
import oshi.api.internal.AbstractContainer;
import oshi.driver.ComponentDriver;

/**
 * A network interface
 */
@Generated("oshi.ApiGenerator")
public abstract class NicContainer extends AbstractContainer implements Nic {
    /**
     * The interface's name
     */
    public String name;

    /**
     * The interface's description
     */
    public String description;

    /**
     * The maximum transmission unit
     */
    public Integer mtu;

    public String mac;

    public Boolean virtual;

    /**
     * The interface's IPv4 addresses
     */
    public String[] ipv4;

    /**
     * The interface's IPv6 addresses
     */
    public String[] ipv6;

    public String broadcast;

    /**
     * The interface's subnet mask
     */
    public String netmask;

    /**
     * The number of bytes read from the interface
     */
    public Long readBytes;

    /**
     * The number of bytes written to the interface
     */
    public Long writeBytes;

    /**
     * The number of packets read from the interface
     */
    public Long readPackets;

    /**
     * The number of packets written to the interface
     */
    public Long writePackets;

    /**
     * The number of read errors
     */
    public Long readErrors;

    /**
     * The number of write errors
     */
    public Long writeErrors;

    /**
     * The number of read drops
     */
    public Long readDrops;

    /**
     * The number of write drops
     */
    public Long writeDrops;

    /**
     * The number of write collisions
     */
    public Long writeCollisions;

    /**
     * The interface's maximum speed in bytes
     */
    public Long linkSpeed;

    public Boolean defaultGateway;

    public Boolean flagUp;

    public Boolean flagRunning;

    public Boolean flagLoopback;

    public Boolean flagMulticast;

    @Override
    public String getName() {
        return name;
    }

    @Override
    public String getDescription() {
        return description;
    }

    @Override
    public Integer getMtu() {
        return mtu;
    }

    @Override
    public Integer queryMtu() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(NicAttributeEnum.MTU);
        return mtu;
    }

    @Override
    public String getMac() {
        return mac;
    }

    @Override
    public String queryMac() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(NicAttributeEnum.MAC);
        return mac;
    }

    @Override
    public Boolean getVirtual() {
        return virtual;
    }

    @Override
    public Boolean queryVirtual() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(NicAttributeEnum.VIRTUAL);
        return virtual;
    }

    @Override
    public String[] getIpv4() {
        return ipv4;
    }

    @Override
    public String[] queryIpv4() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(NicAttributeEnum.IPV4);
        return ipv4;
    }

    @Override
    public String[] getIpv6() {
        return ipv6;
    }

    @Override
    public String[] queryIpv6() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(NicAttributeEnum.IPV6);
        return ipv6;
    }

    @Override
    public String getBroadcast() {
        return broadcast;
    }

    @Override
    public String queryBroadcast() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(NicAttributeEnum.BROADCAST);
        return broadcast;
    }

    @Override
    public String getNetmask() {
        return netmask;
    }

    @Override
    public String queryNetmask() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(NicAttributeEnum.NETMASK);
        return netmask;
    }

    @Override
    public Long getReadBytes() {
        return readBytes;
    }

    @Override
    public Long queryReadBytes() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(NicAttributeEnum.READ_BYTES);
        return readBytes;
    }

    @Override
    public Long getWriteBytes() {
        return writeBytes;
    }

    @Override
    public Long queryWriteBytes() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(NicAttributeEnum.WRITE_BYTES);
        return writeBytes;
    }

    @Override
    public Long getReadPackets() {
        return readPackets;
    }

    @Override
    public Long queryReadPackets() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(NicAttributeEnum.READ_PACKETS);
        return readPackets;
    }

    @Override
    public Long getWritePackets() {
        return writePackets;
    }

    @Override
    public Long queryWritePackets() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(NicAttributeEnum.WRITE_PACKETS);
        return writePackets;
    }

    @Override
    public Long getReadErrors() {
        return readErrors;
    }

    @Override
    public Long queryReadErrors() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(NicAttributeEnum.READ_ERRORS);
        return readErrors;
    }

    @Override
    public Long getWriteErrors() {
        return writeErrors;
    }

    @Override
    public Long queryWriteErrors() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(NicAttributeEnum.WRITE_ERRORS);
        return writeErrors;
    }

    @Override
    public Long getReadDrops() {
        return readDrops;
    }

    @Override
    public Long queryReadDrops() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(NicAttributeEnum.READ_DROPS);
        return readDrops;
    }

    @Override
    public Long getWriteDrops() {
        return writeDrops;
    }

    @Override
    public Long queryWriteDrops() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(NicAttributeEnum.WRITE_DROPS);
        return writeDrops;
    }

    @Override
    public Long getWriteCollisions() {
        return writeCollisions;
    }

    @Override
    public Long queryWriteCollisions() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(NicAttributeEnum.WRITE_COLLISIONS);
        return writeCollisions;
    }

    @Override
    public Long getLinkSpeed() {
        return linkSpeed;
    }

    @Override
    public Long queryLinkSpeed() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(NicAttributeEnum.LINK_SPEED);
        return linkSpeed;
    }

    @Override
    public Boolean getDefaultGateway() {
        return defaultGateway;
    }

    @Override
    public Boolean queryDefaultGateway() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(NicAttributeEnum.DEFAULT_GATEWAY);
        return defaultGateway;
    }

    @Override
    public Boolean getFlagUp() {
        return flagUp;
    }

    @Override
    public Boolean queryFlagUp() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(NicAttributeEnum.FLAG_UP);
        return flagUp;
    }

    @Override
    public Boolean getFlagRunning() {
        return flagRunning;
    }

    @Override
    public Boolean queryFlagRunning() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(NicAttributeEnum.FLAG_RUNNING);
        return flagRunning;
    }

    @Override
    public Boolean getFlagLoopback() {
        return flagLoopback;
    }

    @Override
    public Boolean queryFlagLoopback() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(NicAttributeEnum.FLAG_LOOPBACK);
        return flagLoopback;
    }

    @Override
    public Boolean getFlagMulticast() {
        return flagMulticast;
    }

    @Override
    public Boolean queryFlagMulticast() {
        if (driver == null) {
            throw new DetachedContainerException();
        }
        driver.query(NicAttributeEnum.FLAG_MULTICAST);
        return flagMulticast;
    }

    public void attach(ComponentDriver driver) {
        this.driver = driver;
        // Query all constant attributes:
        driver.query(NicAttributeEnum.NAME);
        driver.query(NicAttributeEnum.DESCRIPTION);
    }

    @Override
    public <T> T get(AttributeKey<T> key) {
        switch ((NicAttributeEnum) key.getAttributeEnum()) {
        default:
            return null;
        case NAME:
            return (T) name;
        case DESCRIPTION:
            return (T) description;
        case MTU:
            return (T) mtu;
        case MAC:
            return (T) mac;
        case VIRTUAL:
            return (T) virtual;
        case IPV4:
            return (T) ipv4;
        case IPV6:
            return (T) ipv6;
        case BROADCAST:
            return (T) broadcast;
        case NETMASK:
            return (T) netmask;
        case READ_BYTES:
            return (T) readBytes;
        case WRITE_BYTES:
            return (T) writeBytes;
        case READ_PACKETS:
            return (T) readPackets;
        case WRITE_PACKETS:
            return (T) writePackets;
        case READ_ERRORS:
            return (T) readErrors;
        case WRITE_ERRORS:
            return (T) writeErrors;
        case READ_DROPS:
            return (T) readDrops;
        case WRITE_DROPS:
            return (T) writeDrops;
        case WRITE_COLLISIONS:
            return (T) writeCollisions;
        case LINK_SPEED:
            return (T) linkSpeed;
        case DEFAULT_GATEWAY:
            return (T) defaultGateway;
        case FLAG_UP:
            return (T) flagUp;
        case FLAG_RUNNING:
            return (T) flagRunning;
        case FLAG_LOOPBACK:
            return (T) flagLoopback;
        case FLAG_MULTICAST:
            return (T) flagMulticast;
        }
    }
}
