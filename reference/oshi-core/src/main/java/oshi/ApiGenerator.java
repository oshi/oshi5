/**
 * OSHI (https://github.com/oshi/oshi)
 *
 * Copyright (c) 2010 - 2019 The OSHI Project Team:
 * https://github.com/oshi/oshi/graphs/contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package oshi;

import static javax.lang.model.element.Modifier.ABSTRACT;
import static javax.lang.model.element.Modifier.PRIVATE;
import static javax.lang.model.element.Modifier.PUBLIC;
import static javax.lang.model.element.Modifier.TRANSIENT;

import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import javax.annotation.processing.Generated;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeSpec;

import oshi.api.DetachedContainerException;

/**
 * This class generates most of the API layer according to a global
 * {@code definitions.json} file in the root project directory. All generated
 * sources are output to the src/gen/java directory.
 */
public final class ApiGenerator {

	/**
	 * The output source folder.
	 */
	private static final Path OUTPUT = Paths.get("src/gen/java");

	/**
	 * The API package prefix.
	 */
	private static final String API_PACKAGE = "oshi.api";

	/**
	 * The driver package prefix.
	 */
	private static final String DRIVER_PACKAGE = "oshi.driver";

	/**
	 * A comment to appear below the license header and above the package
	 * declaration in all generated sources.
	 */
	private static final String GENERATOR_COMMENT = "This file was automatically generated by the OSHI API generator; do not edit!";

	/**
	 * An annotation for all generated sources.
	 */
	private static final AnnotationSpec GENERATOR_ANNOTATION = AnnotationSpec.builder(Generated.class)
			.addMember("value", String.format("\"%s\"", ApiGenerator.class.getName())).build();

	/**
	 * The supported platforms.
	 */
	private static final String[] PLATFORMS = { "Windows", "Mac", "Linux", "Solaris", "FreeBsd" };

	/**
	 * The generator's full output which is collected and written at the end.
	 */
	private static List<JavaFile> files = new ArrayList<>();

	public static void main(String[] argv) throws Exception {
		try (var in = Files.newInputStream(Paths.get("definitions.json"))) {
			List<ComponentJson> json = new ObjectMapper().readValue(in, new TypeReference<List<ComponentJson>>() {
				// The age old anonymous class trick
			});

			for (var component : json) {
				generateAttributeEnums(component);

				generate(component, "");
				for (var platform : PLATFORMS) {
					generate(component, platform);
				}
			}

			generateSystemInterface(json, "");
			for (var platform : PLATFORMS)
				generateSystemInterface(json, platform);
		}

		// Output files if there were no errors
		for (var type : files)
			type.writeTo(OUTPUT);
	}

	private static void generateAttributeEnums(ComponentJson component) {
		String baseName = component.getBaseName();
		String pkgName = component.getPkgName();

		var attributeEnum = TypeSpec.enumBuilder(baseName + "Attribute").addModifiers(PUBLIC)
				.addAnnotation(GENERATOR_ANNOTATION);

		for (var attribute : component.attributes) {
			// Generate enum constant
			attributeEnum.addEnumConstant(attribute.name.toUpperCase());
		}

		files.add(JavaFile.builder(pkgName + ".internal", attributeEnum.build()).addFileComment(GENERATOR_COMMENT)
				.build());
	}

	private static void generate(ComponentJson component, String platform) {
		String baseName = component.getBaseName();
		String pkgName = component.getPkgName();

		// Build classes for component
		var container = TypeSpec.classBuilder(baseName + "Container" + platform).addModifiers(PUBLIC)
				.addAnnotation(GENERATOR_ANNOTATION);
		var containerInterface = TypeSpec.interfaceBuilder(baseName + platform).addModifiers(PUBLIC)
				.addAnnotation(GENERATOR_ANNOTATION);
		var queryAnnotation = TypeSpec.annotationBuilder(baseName + "Query").addModifiers(PUBLIC)
				.addAnnotation(GENERATOR_ANNOTATION)
				.addAnnotation(
						AnnotationSpec.builder(Retention.class)
								.addMember("value", "$T.RUNTIME",
										ClassName.get("java.lang.annotation", "RetentionPolicy"))
								.build())
				.addAnnotation(AnnotationSpec.builder(Target.class)
						.addMember("value", "$T.METHOD", ClassName.get("java.lang.annotation", "ElementType")).build());
		queryAnnotation.addMethod(MethodSpec.methodBuilder("value")
				.returns(ClassName.get(pkgName + ".internal", baseName + "Attribute[]")).addModifiers(PUBLIC, ABSTRACT)
				.build());

		// Setup inheritance
		container.addSuperinterface(ClassName.get(pkgName, baseName + platform));
		if (!platform.isEmpty()) {
			container.superclass(ClassName.get(pkgName + ".internal", baseName + "Container"));
			containerInterface.addSuperinterface(ClassName.get(pkgName, baseName));
		} else {
			container.addModifiers(ABSTRACT);
		}

		if (component.desc != null)
			container.addJavadoc(component.desc + "\n");

		// Add driver field
		container.addField(FieldSpec
				.builder(ClassName.get(DRIVER_PACKAGE, "ComponentDriver"), "driver", PRIVATE, TRANSIENT).build());

		// Create attach method
		var attach = MethodSpec.methodBuilder("attach")
				.addParameter(ClassName.get(DRIVER_PACKAGE, "ComponentDriver"), "driver")
				.addStatement("this.driver = driver").addModifiers(PUBLIC);
		if (!platform.isEmpty())
			attach.addStatement("super.attach(driver)");
		attach.addComment("Query all constant attributes:");

		// Process attributes
		for (var attribute : component.attributes) {
			var type = ClassName.bestGuess(attribute.type);

			if (platform.isEmpty() && attribute.compatible == null
					|| attribute.compatible != null && attribute.compatible.contains(platform.toLowerCase())) {

				if (attribute.constant)
					attach.addStatement("driver.query($T.$L)",
							ClassName.get(pkgName + ".internal", baseName + "Attribute"), attribute.name.toUpperCase());

				// Generate container field
				var containerField = FieldSpec.builder(type, camel(attribute.name), PUBLIC);
				if (attribute.desc != null)
					containerField.addJavadoc(attribute.desc + "\n");
				container.addField(containerField.build());

				// Generate container getter
				var containerGetter = MethodSpec.methodBuilder(camel("get", attribute.name)).returns(type)
						.addStatement("return $L", camel(attribute.name)).addModifiers(PUBLIC)
						.addAnnotation(Override.class);
				container.addMethod(containerGetter.build());

				// Generate container interface getter
				var containerInterfaceGetter = MethodSpec.methodBuilder(camel("get", attribute.name)).returns(type)
						.addModifiers(PUBLIC, ABSTRACT);
				containerInterface.addMethod(containerInterfaceGetter.build());

				// Generate container interface query
				var containerInterfaceQuery = MethodSpec.methodBuilder(camel("query", attribute.name)).returns(type)
						.addModifiers(PUBLIC, ABSTRACT);
				if (!attribute.constant)
					containerInterface.addMethod(containerInterfaceQuery.build());

				// Generate container query delegate
				var containerQuery = MethodSpec.methodBuilder(camel("query", attribute.name)).returns(type)
						.addCode(CodeBlock.builder().beginControlFlow("if (driver == null)")
								.addStatement("throw new $T()", DetachedContainerException.class).endControlFlow()
								.build())
						.addStatement("driver.query($T.$L)",
								ClassName.get(pkgName + ".internal", baseName + "Attribute"),
								attribute.name.toUpperCase())
						.addStatement("return $L", camel(attribute.name)).addModifiers(PUBLIC)
						.addAnnotation(Override.class);

				if (!attribute.constant)
					container.addMethod(containerQuery.build());
			}
		}

		container.addMethod(attach.build());

		files.add(JavaFile.builder(pkgName + ".internal", container.build()).addFileComment(GENERATOR_COMMENT).build());
		files.add(JavaFile.builder(pkgName, containerInterface.build()).addFileComment(GENERATOR_COMMENT).build());
		files.add(JavaFile.builder(pkgName + ".internal", queryAnnotation.build()).addFileComment(GENERATOR_COMMENT)
				.build());

	}

	/**
	 * Generate an interface for top-level System classes for the given components
	 * and platform.
	 * 
	 * @param components
	 * @param platform
	 */
	private static void generateSystemInterface(List<ComponentJson> components, String platform) {
		var system = TypeSpec.interfaceBuilder((platform.isEmpty() ? "Multi" : platform) + "System")
				.addModifiers(PUBLIC).addAnnotation(GENERATOR_ANNOTATION);

		for (var component : components) {
			if (!component.root)
				continue;

			String baseName = component.getBaseName();
			String pkgName = component.getPkgName();

			var type = ClassName.get(pkgName, baseName + platform).box();

			if (component.singular) {
				var get = MethodSpec.methodBuilder(camel("get", baseName)).returns(type).addModifiers(PUBLIC, ABSTRACT);

				system.addMethod(get.build());
			} else {
				type = ParameterizedTypeName.get(ClassName.get(Stream.class), type);
				var get = MethodSpec.methodBuilder(camel("get", baseName, "stream")).returns(type).addModifiers(PUBLIC,
						ABSTRACT);

				system.addMethod(get.build());
			}
		}

		files.add(JavaFile.builder(API_PACKAGE, system.build()).addFileComment(GENERATOR_COMMENT).build());
	}

	/**
	 * Convert the given Strings in underscore format into CamelCase format. The
	 * first character of the first String will always be unchanged.
	 * 
	 * @param strings
	 * @return A CamelCase {@code String}
	 */
	private static String camel(String... strings) {
		if (strings.length == 0)
			return "";
		if (strings[0].isEmpty())
			throw new IllegalArgumentException("First component is empty");

		return strings[0].charAt(0) + Stream.of(strings).map(String::toLowerCase)
				.flatMap(s -> Arrays.stream(s.split("_"))).map(s -> Character.toUpperCase(s.charAt(0)) + s.substring(1))
				.collect(Collectors.joining()).substring(1);
	}

	/**
	 * Represents a system attribute in the definitions file.
	 */
	private static class AttributeJson {
		/**
		 * The attribute's name in lowercase underscore format.
		 */
		public String name;
		/**
		 * The attribute's data type.
		 */
		public String type;
		/**
		 * The attribute's short description.
		 */
		public String desc;
		/**
		 * Whether the attribute's value can change over the lifetime of the system.
		 */
		public boolean constant;
		/**
		 * The attribute's extension type.
		 */
		public String extension;
		/**
		 * A platform compatibility whitelist.
		 */
		public List<String> compatible;
	}

	/**
	 * Represents a system component in the definitions file.
	 */
	private static class ComponentJson {
		/**
		 * The component's name in dot-path notation.
		 */
		public String name;
		/**
		 * Whether the component is accessible from the root of the API.
		 */
		public boolean root;
		/**
		 * Whether the system can contain only one or more than one of the component.
		 */
		public boolean singular;
		/**
		 * The component's short description.
		 */
		public String desc;
		/**
		 * The component's attributes.
		 */
		public List<AttributeJson> attributes;

		/**
		 * Parse the last element of the component's dot-path.
		 * 
		 * @return The component's base name
		 */
		public String getBaseName() {
			return name.substring(name.lastIndexOf('.') + 1);
		}

		/**
		 * Parse the package elements from the component's dot-path.
		 * 
		 * @return The component's package
		 */
		public String getPkgName() {
			return API_PACKAGE + "." + name.substring(0, name.lastIndexOf('.')) + "." + getBaseName().toLowerCase();
		}
	}

	private ApiGenerator() {
	}
}