/**
 * OSHI (https://github.com/oshi/oshi)
 *
 * Copyright (c) 2010 - 2019 The OSHI Project Team:
 * https://github.com/oshi/oshi/graphs/contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package oshi;

import static javax.lang.model.element.Modifier.ABSTRACT;
import static javax.lang.model.element.Modifier.FINAL;
import static javax.lang.model.element.Modifier.PUBLIC;
import static javax.lang.model.element.Modifier.STATIC;

import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import javax.annotation.processing.Generated;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeSpec;
import com.squareup.javapoet.TypeVariableName;
import com.squareup.javapoet.WildcardTypeName;

import oshi.api.AttributeKey;
import oshi.api.Container;
import oshi.api.DetachedContainerException;
import oshi.api.internal.AbstractContainer;
import oshi.driver.AttributeEnum;

/**
 * This class generates most of the API layer according to a global
 * {@code definitions.json} file in the root project directory. All generated
 * sources are output to the src/gen/java directory.
 */
public final class ApiGenerator {

    /**
     * The output source folder.
     */
    private static final Path OUTPUT = Paths.get("src/gen/java");

    /**
     * The API package prefix.
     */
    private static final String API_PACKAGE = "oshi.api";

    /**
     * The driver package prefix.
     */
    private static final String DRIVER_PACKAGE = "oshi.driver";

    /**
     * A comment to appear below the license header and above the package
     * declaration in all generated sources.
     */
    private static final String GENERATOR_COMMENT = "This file was automatically generated by the OSHI API generator; do not edit!";

    /**
     * An annotation to be used on all generated sources.
     */
    private static final AnnotationSpec GENERATOR_ANNOTATION = AnnotationSpec.builder(Generated.class)
            .addMember("value", String.format("\"%s\"", ApiGenerator.class.getName())).build();

    /**
     * The supported platforms.
     */
    private static final String[] PLATFORMS = { "Windows", "Mac", "Linux", "Solaris", "FreeBsd" };

    /**
     * The generator's full output which is collected and written at the end.
     */
    private static List<JavaFile> files = new ArrayList<>();

    public static void main(String[] argv) throws Exception {
        try (var in = Files.newInputStream(Paths.get("definitions.json"))) {
            List<ComponentJson> json = new ObjectMapper().readValue(in, new TypeReference<List<ComponentJson>>() {
                // The old anonymous class trick
            });

            for (var component : json) {
                generateAttributeEnums(component);

                generate(component, "");
                for (var platform : PLATFORMS) {
                    generate(component, platform);
                }
            }

            generateSystemInterface(json, "");
            for (var platform : PLATFORMS)
                generateSystemInterface(json, platform);
        }

        // Output files if there were no errors
        for (var type : files)
            type.writeTo(OUTPUT);
    }

    private static void generateAttributeEnums(ComponentJson component) {
        String baseName = component.getBaseName();
        String pkgName = component.getPkgName();

        var attributeEnum = TypeSpec.enumBuilder(baseName + "AttributeEnum").addModifiers(PUBLIC)
                .addAnnotation(GENERATOR_ANNOTATION).addSuperinterface(ClassName.get(AttributeEnum.class));
        var attributeKey = TypeSpec.classBuilder(baseName + "Attribute").addModifiers(PUBLIC)
                .addAnnotation(GENERATOR_ANNOTATION);

        for (var attribute : component.attributes) {
            var type = ClassName.bestGuess(attribute.type);

            // Generate enum constant
            attributeEnum.addEnumConstant(attribute.name.toUpperCase());

            // Generate attribute key
            var field = FieldSpec.builder(ParameterizedTypeName.get(ClassName.get(AttributeKey.class), type),
                    attribute.name.toUpperCase(), PUBLIC, STATIC, FINAL).initializer("new $T<>($T.$L)",
                            AttributeKey.class, ClassName.get(pkgName + ".internal", baseName + "AttributeEnum"),
                            attribute.name.toUpperCase());
            if (attribute.desc != null)
                field.addJavadoc(attribute.desc + "\n");

            attributeKey.addField(field.build());
        }

        files.add(JavaFile.builder(pkgName + ".internal", attributeEnum.build()).addFileComment(GENERATOR_COMMENT)
                .build());
        files.add(JavaFile.builder(pkgName, attributeKey.build()).addFileComment(GENERATOR_COMMENT).build());
    }

    private static void generate(ComponentJson component, String platform) {
        String baseName = component.getBaseName();
        String pkgName = component.getPkgName();

        // Build classes for component
        var container = TypeSpec.classBuilder(baseName + "Container" + platform).addModifiers(PUBLIC)
                .addAnnotation(GENERATOR_ANNOTATION);
        var containerInterface = TypeSpec.interfaceBuilder(baseName + platform).addModifiers(PUBLIC)
                .addAnnotation(GENERATOR_ANNOTATION);
        var queryAnnotation = TypeSpec.annotationBuilder(baseName + "Query").addModifiers(PUBLIC)
                .addAnnotation(GENERATOR_ANNOTATION)
                .addAnnotation(
                        AnnotationSpec.builder(Retention.class)
                                .addMember("value", "$T.RUNTIME",
                                        ClassName.get("java.lang.annotation", "RetentionPolicy"))
                                .build())
                .addAnnotation(AnnotationSpec.builder(Target.class)
                        .addMember("value", "$T.METHOD", ClassName.get("java.lang.annotation", "ElementType")).build());
        queryAnnotation.addMethod(MethodSpec.methodBuilder("value")
                .returns(ClassName.get(pkgName + ".internal", baseName + "AttributeEnum[]"))
                .addModifiers(PUBLIC, ABSTRACT).build());

        // Setup inheritance
        container.addSuperinterface(ClassName.get(pkgName, baseName + platform));
        if (!platform.isEmpty()) {
            container.superclass(ClassName.get(pkgName + ".internal", baseName + "Container"));
            containerInterface.addSuperinterface(ClassName.get(pkgName, baseName));
        } else {
            container.superclass(ClassName.get(AbstractContainer.class));
            container.addModifiers(ABSTRACT);
            containerInterface.addSuperinterface(ClassName.get(Container.class));
        }

        if (component.desc != null)
            container.addJavadoc(component.desc + "\n");

        // Create attach method
        var attach = MethodSpec.methodBuilder("attach")
                .addParameter(ClassName.get(DRIVER_PACKAGE, "ComponentDriver"), "driver")
                .addStatement("this.driver = driver").addModifiers(PUBLIC);
        if (!platform.isEmpty())
            attach.addStatement("super.attach(driver)");
        attach.addComment("Query all constant attributes:");

        // Create get method
        var getReturn = TypeVariableName.get("T");
        var containerGet = MethodSpec.methodBuilder("get").addTypeVariable(getReturn).returns(getReturn)
                .addModifiers(PUBLIC)
                .addParameter(ParameterizedTypeName.get(ClassName.get(AttributeKey.class), getReturn), "key")
                .addAnnotation(Override.class);
        containerGet.beginControlFlow("switch(($T) key.getAttributeEnum())",
                ClassName.get(pkgName + ".internal", baseName + "AttributeEnum"));
        if (!platform.isEmpty())
            containerGet.addStatement("default: return super.get(key)");
        else
            containerGet.addStatement("default: return null");

        // Process attributes
        for (var attribute : component.attributes) {
            var type = ClassName.bestGuess(attribute.type);

            if (platform.isEmpty() && attribute.compatible == null
                    || attribute.compatible != null && attribute.compatible.contains(platform.toLowerCase())) {

                if (attribute.constant)
                    attach.addStatement("driver.query($T.$L)",
                            ClassName.get(pkgName + ".internal", baseName + "AttributeEnum"),
                            attribute.name.toUpperCase());

                // Generate container field
                var containerField = FieldSpec.builder(type, camel(attribute.name), PUBLIC);
                if (attribute.desc != null)
                    containerField.addJavadoc(attribute.desc + "\n");
                container.addField(containerField.build());

                // Generate container getter
                var containerGetter = MethodSpec.methodBuilder(camel("get", attribute.name)).returns(type)
                        .addStatement("return $L", camel(attribute.name)).addModifiers(PUBLIC)
                        .addAnnotation(Override.class);
                container.addMethod(containerGetter.build());

                // Generate container interface getter
                var containerInterfaceGetter = MethodSpec.methodBuilder(camel("get", attribute.name)).returns(type)
                        .addModifiers(PUBLIC, ABSTRACT);
                containerInterface.addMethod(containerInterfaceGetter.build());

                // Generate container interface query
                var containerInterfaceQuery = MethodSpec.methodBuilder(camel("query", attribute.name)).returns(type)
                        .addModifiers(PUBLIC, ABSTRACT);
                if (!attribute.constant)
                    containerInterface.addMethod(containerInterfaceQuery.build());

                // Generate container query delegate
                var containerQuery = MethodSpec.methodBuilder(camel("query", attribute.name)).returns(type)
                        .addCode(CodeBlock.builder().beginControlFlow("if (driver == null)")
                                .addStatement("throw new $T()", DetachedContainerException.class).endControlFlow()
                                .build())
                        .addStatement("driver.query($T.$L)",
                                ClassName.get(pkgName + ".internal", baseName + "AttributeEnum"),
                                attribute.name.toUpperCase())
                        .addStatement("return $L", camel(attribute.name)).addModifiers(PUBLIC)
                        .addAnnotation(Override.class);

                if (!attribute.constant)
                    container.addMethod(containerQuery.build());

                //
                containerGet.addStatement("case $L: return (T) $L", attribute.name.toUpperCase(),
                        camel(attribute.name));
            }
        }

        container.addMethod(attach.build());

        containerGet.endControlFlow();
        container.addMethod(containerGet.build());

        files.add(JavaFile.builder(pkgName + ".internal", container.build()).addFileComment(GENERATOR_COMMENT).build());
        files.add(JavaFile.builder(pkgName, containerInterface.build()).addFileComment(GENERATOR_COMMENT).build());
        files.add(JavaFile.builder(pkgName + ".internal", queryAnnotation.build()).addFileComment(GENERATOR_COMMENT)
                .build());

    }

    /**
     * Generate an interface for top-level System classes for the given
     * components and platform.
     * 
     * @param components
     * @param platform
     */
    private static void generateSystemInterface(List<ComponentJson> components, String platform) {
        var system = TypeSpec.interfaceBuilder((platform.isEmpty() ? "Multi" : platform) + "System")
                .addModifiers(PUBLIC).addAnnotation(GENERATOR_ANNOTATION);

        if (!platform.isEmpty()) {
            system.addSuperinterface(ClassName.get(API_PACKAGE, "MultiSystem"));
        }

        for (var component : components) {
            if (!component.root)
                continue;

            String baseName = component.getBaseName();
            String pkgName = component.getPkgName();

            var type = ClassName.get(pkgName, baseName + platform).box();

            if (component.singular) {
                var get = MethodSpec.methodBuilder(camel("get", baseName)).returns(type).addModifiers(PUBLIC, ABSTRACT);

                system.addMethod(get.build());
            } else {
                type = ParameterizedTypeName.get(ClassName.get(Stream.class), WildcardTypeName.subtypeOf(type));
                var get = MethodSpec.methodBuilder(camel("get", baseName, "stream")).returns(type).addModifiers(PUBLIC,
                        ABSTRACT);

                system.addMethod(get.build());
            }
        }

        files.add(JavaFile.builder(API_PACKAGE, system.build()).addFileComment(GENERATOR_COMMENT).build());
    }

    /**
     * Convert the given Strings in underscore format into CamelCase format. The
     * first character of the first String will always be unchanged.
     * 
     * @param strings
     * @return A CamelCase {@code String}
     */
    private static String camel(String... strings) {
        if (strings.length == 0)
            return "";
        if (strings[0].isEmpty())
            throw new IllegalArgumentException("First component is empty");

        return strings[0].charAt(0) + Stream.of(strings).map(String::toLowerCase)
                .flatMap(s -> Arrays.stream(s.split("_"))).map(s -> Character.toUpperCase(s.charAt(0)) + s.substring(1))
                .collect(Collectors.joining()).substring(1);
    }

    /**
     * Represents a system attribute in the definitions file.
     */
    private static class AttributeJson {
        /**
         * The attribute's name in lowercase underscore format.
         */
        public String name;
        /**
         * The attribute's data type.
         */
        public String type;
        /**
         * The attribute's short description.
         */
        public String desc;
        /**
         * Whether the attribute's value can change over the lifetime of the
         * system.
         */
        public boolean constant;
        /**
         * The attribute's extension type.
         */
        public String extension;
        /**
         * A platform compatibility whitelist.
         */
        public List<String> compatible;
    }

    /**
     * Represents a system component in the definitions file.
     */
    private static class ComponentJson {
        /**
         * The component's name in dot-path notation.
         */
        public String name;
        /**
         * Whether the component is accessible from the root of the API.
         */
        public boolean root;
        /**
         * Whether the system can contain only one or more than one of the
         * component.
         */
        public boolean singular;
        /**
         * The component's short description.
         */
        public String desc;
        /**
         * The component's attributes.
         */
        public List<AttributeJson> attributes;

        /**
         * Parse the last element of the component's dot-path.
         * 
         * @return The component's base name
         */
        public String getBaseName() {
            return name.substring(name.lastIndexOf('.') + 1);
        }

        /**
         * Parse the package elements from the component's dot-path.
         * 
         * @return The component's package
         */
        public String getPkgName() {
            return API_PACKAGE + "." + name.substring(0, name.lastIndexOf('.')) + "." + getBaseName().toLowerCase();
        }
    }

    private ApiGenerator() {
    }
}